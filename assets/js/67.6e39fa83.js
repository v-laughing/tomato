(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{1220:function(t,a,s){"use strict";s.r(a);var v=s(7),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"编译过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译过程"}},[t._v("#")]),t._v(" 编译过程")]),t._v(" "),v("p",[t._v("以下是一个 hello.c 程序：")]),t._v(" "),v("div",{staticClass:"language-c extra-class"},[v("pre",{pre:!0,attrs:{class:"language-c"}},[v("code",[v("span",{pre:!0,attrs:{class:"token macro property"}},[v("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),v("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello, world\\n"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),v("p",[t._v("在 Unix 系统上，由编译器把源文件转换为目标文件。")]),t._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[t._v("gcc -o hello hello.c\n")])])]),v("p",[t._v("这个过程大致如下：")]),t._v(" "),v("p",[v("img",{attrs:{src:s(662),alt:"avatar"}}),v("br")]),t._v(" "),v("h4",{attrs:{id:"预处理阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#预处理阶段"}},[t._v("#")]),t._v(" 预处理阶段")]),t._v(" "),v("p",[t._v("程序预处理，主要处理源码中的以"),v("code",[t._v("#")]),t._v("开始的预编译指令，如"),v("code",[t._v("#include")]),t._v("、"),v("code",[t._v("#define")]),t._v("等。")]),t._v(" "),v("ul",[v("li",[t._v("根据"),v("code",[t._v("#define")]),t._v("宏定义替换，根据"),v("code",[t._v("#include")]),t._v("递归将整个文件包含进来。")]),t._v(" "),v("li",[t._v("删除所有注释，并添加行号和文件名。")]),t._v(" "),v("li",[t._v("保留所有的#pragma编译器指令。")])]),t._v(" "),v("h4",{attrs:{id:"编译阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译阶段"}},[t._v("#")]),t._v(" 编译阶段")]),t._v(" "),v("p",[t._v("把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件。")]),t._v(" "),v("blockquote",[v("p",[t._v("汇编文件中通过符号"),v("code",[t._v("Symbol")]),t._v("来定位函数或一些变量的地址。对于内联的符号，会在汇编阶段被重新计算为虚拟地址，对于外联符号，会在链接阶段被重定位。")])]),t._v(" "),v("h4",{attrs:{id:"汇编阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#汇编阶段"}},[t._v("#")]),t._v(" 汇编阶段")]),t._v(" "),v("p",[t._v("将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。")]),t._v(" "),v("p",[t._v("此阶段产生的一般称为"),v("strong",[t._v("可重定位目标文件")]),t._v("，在Windows下，可以统称为PE-COFF文件格式。在Linux下，被统称为ELF文件。")]),t._v(" "),v("p",[t._v("该目标文件主要包含：机器指令代码、数据、符号表等。")]),t._v(" "),v("p",[t._v("文件中的内容以「段」的形式存储，不同段存储不同内容。")]),t._v(" "),v("p",[v("code",[t._v(".code")]),t._v("或"),v("code",[t._v(".text")]),t._v("： 机器指令。")]),t._v(" "),v("p",[v("code",[t._v(".data")]),t._v("：已初始化的全局变量和局部静态变量。")]),t._v(" "),v("p",[v("code",[t._v(".bss")]),t._v("：未初始化的全局变量和局部静态变量，此时默认值为0，因而该字段初始时并未给变量分配内容。")]),t._v(" "),v("p",[v("code",[t._v(".rodata")]),t._v("：只读数据，如const变量或字符串常量。")]),t._v(" "),v("p",[v("code",[t._v(".symtab")]),t._v("：符号表，包含符号及其地址。")]),t._v(" "),v("h4",{attrs:{id:"链接阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#链接阶段"}},[t._v("#")]),t._v(" 链接阶段")]),t._v(" "),v("p",[t._v("将可多个重定位目标文件进行合并，得到最终的可执行目标文件。每个目标文件都维护着一个符号表，此过程的主要目的即是确定各个符号的值（地址）。")]),t._v(" "),v("p",[t._v("符号分为三种：")]),t._v(" "),v("ul",[v("li",[t._v("全局符号：由本模块定义并能被其他模块引用。如非静态的 C 函数和全局变量。")]),t._v(" "),v("li",[t._v("外部符号：非本模块定义，引用其他模块。")]),t._v(" "),v("li",[t._v("本地符号：在本模块定义，只能被本模块引用。如静态的 C 函数和全局变量。")])]),t._v(" "),v("p",[t._v("合并过程中可能产生符号「重复定义」问题。编译器将函数和初始化了的全局变量定义为"),v("strong",[t._v("强符号")]),t._v("，未初始化的全局变量为"),v("strong",[t._v("弱符号")]),t._v("，并遵守以下规则：")]),t._v(" "),v("ul",[v("li",[t._v("不允许强符号被多次定义。")]),t._v(" "),v("li",[t._v("如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。")]),t._v(" "),v("li",[t._v("如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。")])]),t._v(" "),v("h1",{attrs:{id:"静态链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态链接"}},[t._v("#")]),t._v(" 静态链接")]),t._v(" "),v("p",[t._v("静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：")]),t._v(" "),v("ul",[v("li",[t._v("符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。")]),t._v(" "),v("li",[t._v("重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。")])]),t._v(" "),v("p",[v("img",{attrs:{src:s(663),alt:"avatar"}}),v("br")]),t._v(" "),v("h1",{attrs:{id:"动态链接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态链接"}},[t._v("#")]),t._v(" 动态链接")]),t._v(" "),v("p",[t._v("静态库有以下两个问题：")]),t._v(" "),v("ul",[v("li",[t._v("当静态库更新时那么整个程序都要重新进行链接；")]),t._v(" "),v("li",[t._v("对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。")])]),t._v(" "),v("p",[t._v("共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：")]),t._v(" "),v("ul",[v("li",[t._v("在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；")]),t._v(" "),v("li",[t._v("在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。")])]),t._v(" "),v("p",[v("img",{attrs:{src:s(664),alt:"avatar"}}),v("br")])])}),[],!1,null,null,null);a.default=_.exports},662:function(t,a,s){t.exports=s.p+"assets/img/b396d726-b75f-4a32-89a2-03a7b6e19f6f.62b33b5e.jpg"},663:function(t,a,s){t.exports=s.p+"assets/img/47d98583-8bb0-45cc-812d-47eefa0a4a40.aa1fc122.jpg"},664:function(t,a){t.exports="data:image/jpeg;base64,"}}]);