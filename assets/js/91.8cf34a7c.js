(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{1215:function(a,t,r){"use strict";r.r(t);var s=r(7),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"程序如何运行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序如何运行"}},[a._v("#")]),a._v(" 程序如何运行")]),a._v(" "),s("p",[a._v("在多道程序环境下，要使程序运行，必须先为之创建进程。")]),a._v(" "),s("h2",{attrs:{id:"程序运行准备"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序运行准备"}},[a._v("#")]),a._v(" 程序运行准备")]),a._v(" "),s("p",[a._v("创建进程的第一件事，便是将程序和数据装入内存。这其中包括三个步骤：编译、链接、装入。")]),a._v(" "),s("h3",{attrs:{id:"编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[a._v("#")]),a._v(" 编译")]),a._v(" "),s("p",[a._v("由编译程序(Compiler)将用户源代码编译成cpu可执行的若干目标模块。程序中的地址为逻辑地址。")]),a._v(" "),s("h3",{attrs:{id:"链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链接"}},[a._v("#")]),a._v(" 链接")]),a._v(" "),s("p",[a._v("由链接程序(Linker)将目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load  Module)。")]),a._v(" "),s("h3",{attrs:{id:"装入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#装入"}},[a._v("#")]),a._v(" 装入")]),a._v(" "),s("p",[a._v("由装入程序(Loader)将装入模块装入物理内存。需要进行地址重定位：把逻辑地址转换成物理内存绝对地址。")]),a._v(" "),s("p",[s("img",{attrs:{src:r(661),alt:"avatar"}}),s("br")]),a._v(" "),s("h2",{attrs:{id:"程序的链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序的链接"}},[a._v("#")]),a._v(" 程序的链接")]),a._v(" "),s("p",[s("img",{attrs:{src:r(662),alt:"avatar"}}),s("br")]),a._v(" "),s("p",[a._v("根据链接时间的不同，可把链接分成如下三种：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("静态链接")]),a._v("。在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块。")]),a._v(" "),s("li",[s("strong",[a._v("装入时动态链接")]),a._v("。在装入内存时，采用边装入边链接的链接方式。")]),a._v(" "),s("li",[s("strong",[a._v("运行时动态链接")]),a._v("。在程序执行中需要该目标模块时，才对它进行的链接和装入。加快装入速度，节省内存空间。")])]),a._v(" "),s("h2",{attrs:{id:"程序的装入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序的装入"}},[a._v("#")]),a._v(" 程序的装入")]),a._v(" "),s("h3",{attrs:{id:"绝对装入方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#绝对装入方式"}},[a._v("#")]),a._v(" 绝对装入方式")]),a._v(" "),s("p",[a._v("在编译时，如果知道程序将驻留在内存的什么位置，那么，编译程序将产生"),s("mark",[a._v("绝对地址的目标代码")]),a._v("。只适用于单道程序环境。")]),a._v(" "),s("h3",{attrs:{id:"可重定位装入方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可重定位装入方式"}},[a._v("#")]),a._v(" 可重定位装入方式")]),a._v(" "),s("p",[a._v("在装入时，完成虚拟地址到内存地址的映射。")]),a._v(" "),s("p",[a._v("缺点：")]),a._v(" "),s("ul",[s("li",[a._v("程序重定位之后就"),s("mark",[a._v("不能在内存中搬动")]),a._v("了。")]),a._v(" "),s("li",[a._v("要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域中。")])]),a._v(" "),s("h3",{attrs:{id:"动态运行时装入方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态运行时装入方式"}},[a._v("#")]),a._v(" 动态运行时装入方式")]),a._v(" "),s("p",[a._v("在程序执行过程中进行地址变换，这意味着目标模块装入内存时无需修改地址。\n为使地址转换不影响指令的执行速度，这种方式需要一个"),s("mark",[a._v("重定位寄存器")]),a._v("的支持")])])}),[],!1,null,null,null);t.default=v.exports},661:function(a,t,r){a.exports=r.p+"assets/img/program-works.7eaa3861.jpg"},662:function(a,t,r){a.exports=r.p+"assets/img/program-link.829f7b1c.jpg"}}]);